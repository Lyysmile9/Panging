信号量
	为了防止出现多个程序同时访问一个共享资源而引发的问题，需要采取一种机制，使得在任一时刻，只有一个进程可以访问到临界区域，即信号量机制。
	信号量分类
		二进制信号量(二元信号量)：取值为0、1
		通用信号量：取值可为0或任意正整数。

PV操作
	p操作
		如果信号量的值大于0，就给它减1；
		如果信号量的值等于0，就挂起该进程的执行。
	v操作
		如果有其他进程因等待信号量而被挂起，就让它恢复运行
		如果没有进程因等待信号量而挂起，就给它加1
	对普通变量进行加减是不行的，因为在c\c++等语言中，没有一个原子操作可以完成变脸检测和加减的功能。

信号量处理函数
	以下几个函数用于处理信号量操作
		#include <sys/types.h>
		#include <sys/ipc.h>
		#include <sys/sem.h>
		int semget(key_t key, int num_sems, int sem_flags);
		int semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);
		int semctl(int sem_id int sem_num, int command, ...); 

semget函数
	该函数的作用是创建一个新信号量，或取得一个已有信号量。
		key：整数值。不相关的进程可以通过它来访问同一个信号量。
		程序对信号量的访问都是间接的，它先提供一个键，再由系统生成一个信号量标识符，其他进程都通过semget函数返回信号量标识符。
		num_sems：整数值。需要的信号量数目，一般总是1.
		sem_flags：一组标志，代表该信号量的权限。IPC_CREAT表示创建一个新的信号量(即使对应键已经创建了信号量，也不会错误)，可以和权限位按位或。

semop函数
	该函数的作用是改变信号量的值
		sem_id：由semget返回的信号量标识符
		sem_ops：指向一个结构数组的指针，该结构描述了信号量操作情况
		num_sem_ops：上述结构数组中元素的个数。
	struct sembuf
	{
		short sem_num;	//信号量编号，如果不适用一组信号量，则
				//取值一般为0
		short sem_op;	//一次操作中希望改变的值，可以为-1，即p
				//操作，也可以为1，即v操作
		short sem_flag;	//通常设为SEM_UNDO,指示操作系统跟踪当前
				//进程对这个信号量的修改情况，如果这个
				//进程没有释放信号量即终止，那么操作系统
				//将自动释放该进程持有的信号量。
	}；

semctl函数
	该函数允许直接控制信号量信息。
		sem_id：信号量标识符。
		sem_num：信号量编号，如果只有一个信号量，取值为0.
		command：
			SETVAL：信号量初始化的标识
			IPC_RMID：删除不再使用的信号量
	如果存在第四个参数，将会是一个union semun结构。这个需要程序员自己定义。
		union semun
		{
			int val;	//信号量初始值
			struct semid_ds* buf;
			unsigned short* array;
		};
