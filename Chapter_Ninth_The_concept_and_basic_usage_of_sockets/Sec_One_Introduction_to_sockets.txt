套接字概念
	套接字是一种进程间通信的方法，不同于以往介绍的进程间通信方法的是，它并不局限于同一台计算机的资源，例如共享内容或者消息队列。
	套接字接口(socket interface)由伯克利版本Unix引入，可以认为是对管道概念的扩展
		一台机器上的进程可以使用套接字与另一台机器上的进程通信。因此客户与服务器可以分散到网络中。
	同一台机器的进程间也可以用套接字通信。

Windows对套接字的支持
	微软的Windows系统也实现了套接字接口，因此Windows程序可以通过网络和Linux/Unix计算机进行通信，实现客户/服务器系统。

套接字工作过程(服务器端)
	首先，服务器应用程序通过socket系统调用创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，不能与其他进程共享。
	其次，服务器进程使用bind系统调用给套接字命名。
		本地套接字的名字是Linux文件系统的文件名，一般将其放在/tmp或者/usr/tmp目录下。
		网络套接字的名字是与客户相连接的特定网络有关的服务标识符。此标识符允许Linux将进入的针对特定端口号的连接转到正确的服务器进程。
	接下来，服务器进程开始等待客户连接到这个命名套接字，调用listen创建一个等待队列，以便存放来自客户的进入连接。
	最后，服务器通过accept系统调用来接受客户的连接。此时，会产生一个与原有的命名套接字不同的新套接字，它仅用于与这个特定的客户通信，而命名套接字则被保留下来继续处理来自其他客户的连接。

套接字工作过程(客户端)
	调用socket创建一个未命名套接字，将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。
	一旦建立了连接，就可以像使用底层文件描述符那样来用套接字进行双向的数据通信。

套接字属性
	套接字的特性由三个属性决定：
		域(domain)
		类型(type)
		协议(protocol)

	域：指定套接字通信中使用的网络介质，包括地址格式。最常用的有以下两种：
		AF_INET，即互联网络，基于IP协议，并且每个服务对应一个端口号，套接字地址由IP地址+端口号决定；
		AF_UNIX，基于本地机器，底层协议使用文件输入/输出，地址为绝对路径的文件名。
	
	类型：一个套接字域可能有不同的通信方式，每种通信方式有不同的特性。
		AF_UNIX域的套接字没有通信方面的问题，因为其基于文件系统，提供了一个可靠的双向通信路径。
	AF_INET域中，需要注意底层网络的特性。
		流套接字：由类型SOCK_STREAM指定，基于TCP/IP实现，提供一个有序、可靠、双向字节流的连接，发送的数据不会丢失、乱序、重复。大的消息会被分块、传输、重组，很像一个文件流。
		数据报套接字：由SOCK_DGRAM指定，基于UDP/IP协议，不建立和维持可靠连接，开销小，服务器崩溃不需要客户端重启，因为基于数据报的服务器不保留连接信息
	
	协议：我们重点讨论网络套接字和文件系统套接字，不需要选择特定协议，只要默认值(0)即可。

套接字举例
	客户端程序：创建一个未命名的套接字，然后把它连接到服务器套接字server_socket上，向服务器写一个字符，再读回经服务器处理后的一个字符。
	服务器端程序：首先创建一个服务器套接字，绑定到一个名字，然后创建一个监听队列，接收来自客户程序的连接。

/*服务器端程序*/
#include <sys/typesh>
#include <sys/socket.h>
#include <stdio.h>
#include <sys/un.h>						//套接字域地址格式，定义在
#include <unistd.h>						//sys/un.h中：
								//struct
int main()							//{
{								//	short int sun_family;	
	int server_sockfd, client_sockfd; //定义套接字标识符	//	char sun_path[108];
	int server_len, client_len;	//地址长度		//};
	struct sockaddr_un server_address;
	struct sockaddr_un client_address;
	unlink("server_socket");				 //如果当前目录有叫做server_socket的文件，则删掉。
	server_sockfd = socket(AF_UNIX, SOCK_STREAM, 0); 	//创建一个AF_UNIX格式的socket，采用字节流方式，默认协议，并返回此socket的文件描述符。
	server_address.sun_family = AF_UNIX;					//为socket命名：设置Unix/Linux文件系统本地套接字地址
	strcpy(server_address.sun_path, "server_socket"); 		       //本地名称
	servet_len = sizeof(server_address);				      //地址长度
	bind(server_sockfd, (struct sockaddr *)&server_address, server_len); //命名套接字
	listen(server_sockfd, 5);			   //创建长度为5的监听队列
	while(1)					  //等待客户端连接的到来
	{
		char ch;
		printf("server waiting\n");
		client_len = sizeof(client_address);	//获取客户端套接字地址长度
		client_sockfd = accept(server_sockfd,  //服务器进程阻塞自身，直到有客户端请求建立连接，此时生成一个新的套接字，并返回套接字的描述符
			(struct sockaddr *)&client_address, &client_len); //用此新套接字与客户进行通信，新套接字类型与服务器监听套接字类型是一样的
		read(client_sockfd, &ch, 1);
		ch++;
		write(client_sockfd, &ch, 1);
		close(client_sockfd);
	}
}

/*客户端程序*/
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <sys/un.h>
#include <unistd.h>

int main()
{
	int sockfd;
	int len;
	struct sockaddr_un address;
	char ch = 'A';
	sockfd = socket(AF_UNIX, SOCK_STREAM, 0); //为客户创建一个套接字
	address.sun_family = AF_UNIX; //根据服务器的情况设定连接地址
	strcpy(address.sun_path, "server_socket"); //服务器地址
	len = sizeof(address);	//地址长度
	result = connect(sockfd, (struct sockaddr *)&address, len); //连接到服务器套接字
	if(result == -1)	//出错则退出
	{
		perror("oops: client1");
	}
	write(sockfd, &ch, 1);	//通过套接字文件描述符读写信息
	read(sockfd, &ch, 1);
	printf("char from server = %c\n", ch);
	close(sockfd);
	exit(0);
}
运行结果：
先运行服务器程序：	然后运行客户端程序：
server waiting		char from server = B
server waiting
