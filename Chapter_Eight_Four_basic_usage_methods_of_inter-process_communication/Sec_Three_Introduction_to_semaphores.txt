信号量
	为了防止出现多个程序同时访问一个共享资源而引发的问题，需要采取一种机制，使得在任一时刻，只有一个进程可以访问到临界区域，即信号量机制。
	信号量分类
		二进制信号量(二元信号量)：取值为0、1
		通用信号量：取值可为0或任意正整数。

PV操作
	p操作
		如果信号量的值大于0，就给它减1；
		如果信号量的值等于0，就挂起该进程的执行。
	v操作
		如果有其他进程因等待信号量而被挂起，就让它恢复运行
		如果没有进程因等待信号量而挂起，就给它加1
	对普通变量进行加减是不行的，因为在c\c++等语言中，没有一个原子操作可以完成变脸检测和加减的功能。

信号量处理函数
	以下几个函数用于处理信号量操作
		#include <sys/types.h>
		#include <sys/ipc.h>
		#include <sys/sem.h>
		int semget(key_t key, int num_sems, int sem_flags);
		int semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);
		int semctl(int sem_id int sem_num, int command, ...); 

semget函数
	该函数的作用是创建一个新信号量，或取得一个已有信号量。
		key：整数值。不相关的进程可以通过它来访问同一个信号量。
		程序对信号量的访问都是间接的，它先提供一个键，再由系统生成一个信号量标识符，其他进程都通过semget函数返回信号量标识符。
		num_sems：整数值。需要的信号量数目，一般总是1.
		sem_flags：一组标志，代表该信号量的权限。IPC_CREAT表示创建一个新的信号量(即使对应键已经创建了信号量，也不会错误)，可以和权限位按位或。

semop函数
	该函数的作用是改变信号量的值
		sem_id：由semget返回的信号量标识符
		sem_ops：指向一个结构数组的指针，该结构描述了信号量操作情况
		num_sem_ops：上述结构数组中元素的个数。
	struct sembuf
	{
		short sem_num;	//信号量编号，如果不适用一组信号量，则
				//取值一般为0
		short sem_op;	//一次操作中希望改变的值，可以为-1，即p
				//操作，也可以为1，即v操作
		short sem_flag;	//通常设为SEM_UNDO,指示操作系统跟踪当前
				//进程对这个信号量的修改情况，如果这个
				//进程没有释放信号量即终止，那么操作系统
				//将自动释放该进程持有的信号量。
	}；

semctl函数
	该函数允许直接控制信号量信息。
		sem_id：信号量标识符。
		sem_num：信号量编号，如果只有一个信号量，取值为0.
		command：
			SETVAL：信号量初始化的标识
			IPC_RMID：删除不再使用的信号量
	如果存在第四个参数，将会是一个union semun结构。这个需要程序员自己定义。
		union semun
		{
			int val;	//信号量初始值
			struct semid_ds* buf;
			unsigned short* array;
		};

信号量使用举例
	用两个不同字符的输出代表进入和离开缓冲区。
	如果程序启动时带有一个参数，它将在进入和退出临界区域时打印字符X，而程序的其他运行实例将再进入和退出临界区域时打印字符O。
	因为在任意给定时刻，只有一个进程能进入临界区域，因此字符X和O都应成对出现。

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

union semun		//设置semctl函数要用的联合体类型
{
	int val;
	struct semid_ds *buf;
	unsigned short int *array;
	struct seminfo* __buf;
};

static int set_semvalue(void);		//函数声明、信号量定义
static void del_semvalue(void);
static int semaphore_p(void);
static int semaphore_v(void);
static int sem_id;

int main()
{
	int i;		//变量初值
	int pause_time;
	char op_char = 'O';
	srand((unsigned int)getpid());	//随机种子
	sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT); //创建一个信号量
	if(argc > 1)	//如果有参数，设置信号量，修改字符变量为X，睡眠5秒
	{
		if(!set_semvalue())	//将信号量值初始化为1
		{
			fprintf(stderr, "Failed to initialize semaphore\n");
			exit(EXIT_FAILURE);
		}
		op_char = 'X';
		sleep(5);
	}
	for(i = 0; i < 10; i++)
	{
		if(!semaphore_p())	//执行P操作，进入临界区，输出字符，退出临界区，执行v操作
			exit(EXIT_FAILURE);
		printf("%c", op_char);
		fflush(stdout);		//保证一定能输出
		pause_time = rand() % 3;
		sleep(pause_time);
		printf("%c", op_char);
		fflush(stdout);
		if(!semaphore_v())
			exit(EXIT_FAILURE);
		pause_time = rand() % 2;
		sleep(pause_time);
	}
	printf("\n%d - finished\n", geipid());

	if(argc > 1)	//第一个进程睡眠10秒，删除信号量，程序结束
	{
		sleep(10);
		del_semvalue();
	}
	exit(EXIT_SUCCESS);
}

static int set_semvalue(void)	//初始化信号量
{
	union semun sem_union;
	sem_union.val = 1;
	
	if(semctl(sem_id, 0, SETVAL, sem_union) == -1)
		return(0);
	return(1);
}

static void del_semvalue(void)	//删除信号量
{
	union semun sem_union;

	if(semctl(sem_id, 0, IPC_RMID, sem_union) == -1)
		fprintf(stderr, "Failed to delete semaphore\n");
}

static int semaphore_p(void)	//P操作
{
	struct sembuf sem_b;
	sem_b.sem_num = 0;
	sem_b.sem_op = -1;	//*****
	sem_b.sem_flg = SEM_UNDO;

	if(semop(sem_id, &sem_b, 1) == -1)
	{
		fprintf(stderr, "semaphore_p failed\n");
		return(0);
	}
	return(1);
}

static int semaphore_v(void)	//v操作
{
	struct sembuf sem_b;

	sem_b.sem_num = 0;
	sem_b.sem_op = 1;	//***
	sem_b.sem_flg = SEM_UNDO;

	if(semop(sem_id, $sem_b, 1) == -1)
	{
		fprintf(stderr, "semaphore_v failed\n");
		return(0);
	}
	return(1);
}
